{"version":3,"file":"output_parsers.js","names":["params: GoogleGenerativeAIToolsOutputParserParams<T>","result: unknown","generations: ChatGeneration[]"],"sources":["../src/output_parsers.ts"],"sourcesContent":["import {\n  BaseLLMOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport { ChatGeneration } from \"@langchain/core/outputs\";\nimport { ToolCall } from \"@langchain/core/messages/tool\";\nimport {\n  InteropZodType,\n  interopSafeParseAsync,\n} from \"@langchain/core/utils/types\";\nimport { JsonOutputKeyToolsParserParamsInterop } from \"@langchain/core/output_parsers/openai_tools\";\n\ninterface GoogleGenerativeAIToolsOutputParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any>\n> extends JsonOutputKeyToolsParserParamsInterop<T> {}\n\nexport class GoogleGenerativeAIToolsOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends BaseLLMOutputParser<T> {\n  static lc_name() {\n    return \"GoogleGenerativeAIToolsOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"google_genai\", \"output_parsers\"];\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: GoogleGenerativeAIToolsOutputParserParams<T>) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const tools = generations.flatMap((generation) => {\n      const { message } = generation;\n      if (!(\"tool_calls\" in message) || !Array.isArray(message.tool_calls)) {\n        return [];\n      }\n      return message.tool_calls as ToolCall[];\n    });\n    if (tools[0] === undefined) {\n      throw new Error(\n        \"No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.\"\n      );\n    }\n    const [tool] = tools;\n    const validatedResult = await this._validateResult(tool.args);\n    return validatedResult;\n  }\n}\n"],"mappings":";;;;AAiBA,IAAa,sCAAb,cAGU,oBAAuB;CAC/B,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAgB;CAAiB;CAE9D,WAAW;;CAGX;;CAGA,eAAe;CAEf;CAEA,YAAYA,QAAsD;EAChE,MAAM,OAAO;EACb,KAAK,UAAU,OAAO;EACtB,KAAK,eAAe,OAAO,gBAAgB,KAAK;EAChD,KAAK,YAAY,OAAO;CACzB;CAED,MAAgB,gBAAgBC,QAA6B;AAC3D,MAAI,KAAK,cAAc,OACrB,QAAO;EAET,MAAM,kBAAkB,MAAM,sBAAsB,KAAK,WAAW,OAAO;AAC3E,MAAI,gBAAgB,QAClB,QAAO,gBAAgB;MAEvB,OAAM,IAAI,sBACR,CAAC,wBAAwB,EAAE,KAAK,UAC9B,QACA,MACA,EACD,CAAC,UAAU,EAAE,KAAK,UAAU,gBAAgB,MAAM,OAAO,EAAE,EAC5D,KAAK,UAAU,QAAQ,MAAM,EAAE;CAGpC;CAED,MAAM,YAAYC,aAA2C;EAC3D,MAAM,QAAQ,YAAY,QAAQ,CAAC,eAAe;GAChD,MAAM,EAAE,SAAS,GAAG;AACpB,OAAI,EAAE,gBAAgB,YAAY,CAAC,MAAM,QAAQ,QAAQ,WAAW,CAClE,QAAO,CAAE;AAEX,UAAO,QAAQ;EAChB,EAAC;AACF,MAAI,MAAM,OAAO,OACf,OAAM,IAAI,MACR;EAGJ,MAAM,CAAC,KAAK,GAAG;EACf,MAAM,kBAAkB,MAAM,KAAK,gBAAgB,KAAK,KAAK;AAC7D,SAAO;CACR;AACF"}