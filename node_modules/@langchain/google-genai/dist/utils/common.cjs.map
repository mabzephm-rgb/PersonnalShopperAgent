{"version":3,"file":"common.cjs","names":["message: BaseMessage","ChatMessage","author: string","content: MessageContentComplex","message: ToolMessage | ToolMessageChunk","previousMessages: BaseMessage[]","isMultimodalModel: boolean","standardContentBlockConverter: StandardContentBlockConverter<{\n    text: TextPart;\n    image: FileDataPart | InlineDataPart;\n    audio: FileDataPart | InlineDataPart;\n    file: FileDataPart | InlineDataPart | TextPart;\n  }>","functionCalls: FunctionCallPart[]","messageParts: Part[]","messages: BaseMessage[]","convertSystemMessageToHumanContent: boolean","prevContent","content: Content","response: EnhancedGenerateContentResponse","extra?: {\n    usageMetadata: UsageMetadata | undefined;\n  }","content: MessageContent | undefined","generation: ChatGeneration","AIMessage","extra: {\n    usageMetadata?: UsageMetadata | undefined;\n    index: number;\n  }","toolCallChunks: ToolCallChunk[]","ChatGenerationChunk","AIMessageChunk","tools: GoogleGenerativeAIToolType[]","schemaToGenerativeAIParameters","jsonSchemaToGeminiParameters"],"sources":["../../src/utils/common.ts"],"sourcesContent":["import {\n  EnhancedGenerateContentResponse,\n  Content,\n  Part,\n  type FunctionDeclarationsTool as GoogleGenerativeAIFunctionDeclarationsTool,\n  type FunctionDeclaration as GenerativeAIFunctionDeclaration,\n  POSSIBLE_ROLES,\n  FunctionCallPart,\n  TextPart,\n  FileDataPart,\n  InlineDataPart,\n} from \"@google/generative-ai\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ToolMessage,\n  ToolMessageChunk,\n  MessageContent,\n  MessageContentComplex,\n  UsageMetadata,\n  isAIMessage,\n  isBaseMessage,\n  isToolMessage,\n  StandardContentBlockConverter,\n  parseBase64DataUrl,\n  convertToProviderContentBlock,\n  isDataContentBlock,\n} from \"@langchain/core/messages\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport { isOpenAITool } from \"@langchain/core/language_models/base\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  jsonSchemaToGeminiParameters,\n  schemaToGenerativeAIParameters,\n} from \"./zod_to_genai_parameters.js\";\nimport { GoogleGenerativeAIToolType } from \"../types.js\";\n\nexport function getMessageAuthor(message: BaseMessage) {\n  const type = message._getType();\n  if (ChatMessage.isInstance(message)) {\n    return message.role;\n  }\n  if (type === \"tool\") {\n    return type;\n  }\n  return message.name ?? type;\n}\n\n/**\n * Maps a message type to a Google Generative AI chat author.\n * @param message The message to map.\n * @param model The model to use for mapping.\n * @returns The message type mapped to a Google Generative AI chat author.\n */\nexport function convertAuthorToRole(\n  author: string\n): (typeof POSSIBLE_ROLES)[number] {\n  switch (author) {\n    /**\n     *  Note: Gemini currently is not supporting system messages\n     *  we will convert them to human messages and merge with following\n     * */\n    case \"supervisor\":\n    case \"ai\":\n    case \"model\": // getMessageAuthor returns message.name. code ex.: return message.name ?? type;\n      return \"model\";\n    case \"system\":\n      return \"system\";\n    case \"human\":\n      return \"user\";\n    case \"tool\":\n    case \"function\":\n      return \"function\";\n    default:\n      throw new Error(`Unknown / unsupported author: ${author}`);\n  }\n}\n\nfunction messageContentMedia(content: MessageContentComplex): Part {\n  if (\"mimeType\" in content && \"data\" in content) {\n    return {\n      inlineData: {\n        mimeType: content.mimeType,\n        data: content.data,\n      },\n    };\n  }\n  if (\"mimeType\" in content && \"fileUri\" in content) {\n    return {\n      fileData: {\n        mimeType: content.mimeType,\n        fileUri: content.fileUri,\n      },\n    };\n  }\n\n  throw new Error(\"Invalid media content\");\n}\n\nfunction inferToolNameFromPreviousMessages(\n  message: ToolMessage | ToolMessageChunk,\n  previousMessages: BaseMessage[]\n): string | undefined {\n  return previousMessages\n    .map((msg) => {\n      if (isAIMessage(msg)) {\n        return msg.tool_calls ?? [];\n      }\n      return [];\n    })\n    .flat()\n    .find((toolCall) => {\n      return toolCall.id === message.tool_call_id;\n    })?.name;\n}\n\nfunction _getStandardContentBlockConverter(isMultimodalModel: boolean) {\n  const standardContentBlockConverter: StandardContentBlockConverter<{\n    text: TextPart;\n    image: FileDataPart | InlineDataPart;\n    audio: FileDataPart | InlineDataPart;\n    file: FileDataPart | InlineDataPart | TextPart;\n  }> = {\n    providerName: \"Google Gemini\",\n\n    fromStandardTextBlock(block) {\n      return {\n        text: block.text,\n      };\n    },\n\n    fromStandardImageBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support images\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardAudioBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support audio\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardFileBlock(block): FileDataPart | InlineDataPart | TextPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support files\");\n      }\n      if (block.source_type === \"text\") {\n        return {\n          text: block.text,\n        };\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n  };\n  return standardContentBlockConverter;\n}\n\nfunction _convertLangChainContentToPart(\n  content: MessageContentComplex,\n  isMultimodalModel: boolean\n): Part | undefined {\n  if (isDataContentBlock(content)) {\n    return convertToProviderContentBlock(\n      content,\n      _getStandardContentBlockConverter(isMultimodalModel)\n    );\n  }\n\n  if (content.type === \"text\") {\n    return { text: content.text };\n  } else if (content.type === \"executableCode\") {\n    return { executableCode: content.executableCode };\n  } else if (content.type === \"codeExecutionResult\") {\n    return { codeExecutionResult: content.codeExecutionResult };\n  } else if (content.type === \"image_url\") {\n    if (!isMultimodalModel) {\n      throw new Error(`This model does not support images`);\n    }\n    let source;\n    if (typeof content.image_url === \"string\") {\n      source = content.image_url;\n    } else if (\n      typeof content.image_url === \"object\" &&\n      \"url\" in content.image_url\n    ) {\n      source = content.image_url.url;\n    } else {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n    const [dm, data] = source.split(\",\");\n    if (!dm.startsWith(\"data:\")) {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    const [mimeType, encoding] = dm.replace(/^data:/, \"\").split(\";\");\n    if (encoding !== \"base64\") {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    return {\n      inlineData: {\n        data,\n        mimeType,\n      },\n    };\n  } else if (content.type === \"media\") {\n    return messageContentMedia(content);\n  } else if (content.type === \"tool_use\") {\n    return {\n      functionCall: {\n        name: content.name,\n        args: content.input,\n      },\n    };\n  } else if (\n    content.type?.includes(\"/\") &&\n    // Ensure it's a single slash.\n    content.type.split(\"/\").length === 2 &&\n    \"data\" in content &&\n    typeof content.data === \"string\"\n  ) {\n    return {\n      inlineData: {\n        mimeType: content.type,\n        data: content.data,\n      },\n    };\n  } else if (\"functionCall\" in content) {\n    // No action needed here — function calls will be added later from message.tool_calls\n    return undefined;\n  } else {\n    if (\"type\" in content) {\n      throw new Error(`Unknown content type ${content.type}`);\n    } else {\n      throw new Error(`Unknown content ${JSON.stringify(content)}`);\n    }\n  }\n}\n\nexport function convertMessageContentToParts(\n  message: BaseMessage,\n  isMultimodalModel: boolean,\n  previousMessages: BaseMessage[]\n): Part[] {\n  if (isToolMessage(message)) {\n    const messageName =\n      message.name ??\n      inferToolNameFromPreviousMessages(message, previousMessages);\n    if (messageName === undefined) {\n      throw new Error(\n        `Google requires a tool name for each tool call response, and we could not infer a called tool name for ToolMessage \"${message.id}\" from your passed messages. Please populate a \"name\" field on that ToolMessage explicitly.`\n      );\n    }\n\n    const result = Array.isArray(message.content)\n      ? (message.content\n          .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n          .filter((p) => p !== undefined) as Part[])\n      : message.content;\n\n    if (message.status === \"error\") {\n      return [\n        {\n          functionResponse: {\n            name: messageName,\n            // The API expects an object with an `error` field if the function call fails.\n            // `error` must be a valid object (not a string or array), so we wrap `message.content` here\n            response: { error: { details: result } },\n          },\n        },\n      ];\n    }\n\n    return [\n      {\n        functionResponse: {\n          name: messageName,\n          // again, can't have a string or array value for `response`, so we wrap it as an object here\n          response: { result },\n        },\n      },\n    ];\n  }\n\n  let functionCalls: FunctionCallPart[] = [];\n  const messageParts: Part[] = [];\n\n  if (typeof message.content === \"string\" && message.content) {\n    messageParts.push({ text: message.content });\n  }\n\n  if (Array.isArray(message.content)) {\n    messageParts.push(\n      ...(message.content\n        .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n        .filter((p) => p !== undefined) as Part[])\n    );\n  }\n\n  if (isAIMessage(message) && message.tool_calls?.length) {\n    functionCalls = message.tool_calls.map((tc) => {\n      return {\n        functionCall: {\n          name: tc.name,\n          args: tc.args,\n        },\n      };\n    });\n  }\n\n  return [...messageParts, ...functionCalls];\n}\n\nexport function convertBaseMessagesToContent(\n  messages: BaseMessage[],\n  isMultimodalModel: boolean,\n  convertSystemMessageToHumanContent: boolean = false\n) {\n  return messages.reduce<{\n    content: Content[];\n    mergeWithPreviousContent: boolean;\n  }>(\n    (acc, message, index) => {\n      if (!isBaseMessage(message)) {\n        throw new Error(\"Unsupported message input\");\n      }\n      const author = getMessageAuthor(message);\n      if (author === \"system\" && index !== 0) {\n        throw new Error(\"System message should be the first one\");\n      }\n      const role = convertAuthorToRole(author);\n\n      const prevContent = acc.content[acc.content.length];\n      if (\n        !acc.mergeWithPreviousContent &&\n        prevContent &&\n        prevContent.role === role\n      ) {\n        throw new Error(\n          \"Google Generative AI requires alternate messages between authors\"\n        );\n      }\n\n      const parts = convertMessageContentToParts(\n        message,\n        isMultimodalModel,\n        messages.slice(0, index)\n      );\n\n      if (acc.mergeWithPreviousContent) {\n        const prevContent = acc.content[acc.content.length - 1];\n        if (!prevContent) {\n          throw new Error(\n            \"There was a problem parsing your system message. Please try a prompt without one.\"\n          );\n        }\n        prevContent.parts.push(...parts);\n\n        return {\n          mergeWithPreviousContent: false,\n          content: acc.content,\n        };\n      }\n      let actualRole = role;\n      if (\n        actualRole === \"function\" ||\n        (actualRole === \"system\" && !convertSystemMessageToHumanContent)\n      ) {\n        // GenerativeAI API will throw an error if the role is not \"user\" or \"model.\"\n        actualRole = \"user\";\n      }\n      const content: Content = {\n        role: actualRole,\n        parts,\n      };\n      return {\n        mergeWithPreviousContent:\n          author === \"system\" && !convertSystemMessageToHumanContent,\n        content: [...acc.content, content],\n      };\n    },\n    { content: [], mergeWithPreviousContent: false }\n  ).content;\n}\n\nexport function mapGenerateContentResultToChatResult(\n  response: EnhancedGenerateContentResponse,\n  extra?: {\n    usageMetadata: UsageMetadata | undefined;\n  }\n): ChatResult {\n  // if rejected or error, return empty generations with reason in filters\n  if (\n    !response.candidates ||\n    response.candidates.length === 0 ||\n    !response.candidates[0]\n  ) {\n    return {\n      generations: [],\n      llmOutput: {\n        filters: response.promptFeedback,\n      },\n    };\n  }\n\n  const functionCalls = response.functionCalls();\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  let content: MessageContent | undefined;\n\n  if (\n    Array.isArray(candidateContent?.parts) &&\n    candidateContent.parts.length === 1 &&\n    candidateContent.parts[0].text\n  ) {\n    content = candidateContent.parts[0].text;\n  } else if (\n    Array.isArray(candidateContent?.parts) &&\n    candidateContent.parts.length > 0\n  ) {\n    content = candidateContent.parts.map((p) => {\n      if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  let text = \"\";\n  if (typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content) && content.length > 0) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? text;\n  }\n\n  const generation: ChatGeneration = {\n    text,\n    message: new AIMessage({\n      content: content ?? \"\",\n      tool_calls: functionCalls?.map((fc) => {\n        return {\n          ...fc,\n          type: \"tool_call\",\n          id: \"id\" in fc && typeof fc.id === \"string\" ? fc.id : uuidv4(),\n        };\n      }),\n      additional_kwargs: {\n        ...generationInfo,\n      },\n      usage_metadata: extra?.usageMetadata,\n    }),\n    generationInfo,\n  };\n\n  return {\n    generations: [generation],\n    llmOutput: {\n      tokenUsage: {\n        promptTokens: extra?.usageMetadata?.input_tokens,\n        completionTokens: extra?.usageMetadata?.output_tokens,\n        totalTokens: extra?.usageMetadata?.total_tokens,\n      },\n    },\n  };\n}\n\nexport function convertResponseContentToChatGenerationChunk(\n  response: EnhancedGenerateContentResponse,\n  extra: {\n    usageMetadata?: UsageMetadata | undefined;\n    index: number;\n  }\n): ChatGenerationChunk | null {\n  if (!response.candidates || response.candidates.length === 0) {\n    return null;\n  }\n  const functionCalls = response.functionCalls();\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  let content: MessageContent | undefined;\n  // Checks if some parts do not have text. If false, it means that the content is a string.\n  if (\n    Array.isArray(candidateContent?.parts) &&\n    candidateContent.parts.every((p) => \"text\" in p)\n  ) {\n    content = candidateContent.parts.map((p) => p.text).join(\"\");\n  } else if (Array.isArray(candidateContent?.parts)) {\n    content = candidateContent.parts.map((p) => {\n      if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  let text = \"\";\n  if (content && typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content)) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? \"\";\n  }\n\n  const toolCallChunks: ToolCallChunk[] = [];\n  if (functionCalls) {\n    toolCallChunks.push(\n      ...functionCalls.map((fc) => ({\n        ...fc,\n        args: JSON.stringify(fc.args),\n        index: extra.index,\n        type: \"tool_call_chunk\" as const,\n        id: \"id\" in fc && typeof fc.id === \"string\" ? fc.id : uuidv4(),\n      }))\n    );\n  }\n\n  return new ChatGenerationChunk({\n    text,\n    message: new AIMessageChunk({\n      content: content || \"\",\n      name: !candidateContent ? undefined : candidateContent.role,\n      tool_call_chunks: toolCallChunks,\n      // Each chunk can have unique \"generationInfo\", and merging strategy is unclear,\n      // so leave blank for now.\n      additional_kwargs: {},\n      response_metadata: {\n        model_provider: \"google-genai\",\n      },\n      usage_metadata: extra.usageMetadata,\n    }),\n    generationInfo,\n  });\n}\n\nexport function convertToGenerativeAITools(\n  tools: GoogleGenerativeAIToolType[]\n): GoogleGenerativeAIFunctionDeclarationsTool[] {\n  if (\n    tools.every(\n      (tool) =>\n        \"functionDeclarations\" in tool &&\n        Array.isArray(tool.functionDeclarations)\n    )\n  ) {\n    return tools as GoogleGenerativeAIFunctionDeclarationsTool[];\n  }\n  return [\n    {\n      functionDeclarations: tools.map(\n        (tool): GenerativeAIFunctionDeclaration => {\n          if (isLangChainTool(tool)) {\n            const jsonSchema = schemaToGenerativeAIParameters(tool.schema);\n            if (\n              jsonSchema.type === \"object\" &&\n              \"properties\" in jsonSchema &&\n              Object.keys(jsonSchema.properties).length === 0\n            ) {\n              return {\n                name: tool.name,\n                description: tool.description,\n              };\n            }\n            return {\n              name: tool.name,\n              description: tool.description,\n              parameters: jsonSchema,\n            };\n          }\n          if (isOpenAITool(tool)) {\n            return {\n              name: tool.function.name,\n              description:\n                tool.function.description ?? `A function available to call.`,\n              parameters: jsonSchemaToGeminiParameters(\n                tool.function.parameters\n              ),\n            };\n          }\n          return tool as unknown as GenerativeAIFunctionDeclaration;\n        }\n      ),\n    },\n  ];\n}\n"],"mappings":"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"}